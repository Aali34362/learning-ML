ML.NET gives you the ability to add machine learning to .NET applications, 
in either online or offline scenarios. With this capability, 
you can make automatic predictions using the data available to your application. 
Machine learning applications make use of patterns in the data to make predictions rather than needing to be explicitly programmed.

Central to ML.NET is a machine learning model. 
The model specifies the steps needed to transform your input data into a prediction. 
With ML.NET, you can train a custom model by specifying an algorithm, or you can import pre-trained TensorFlow and ONNX models.

Once you have a model, you can add it to your application to make the predictions.

ML.NET runs on Windows, Linux, and macOS using .NET, or on Windows 
using .NET Framework. 64 bit is supported on all platforms. 32 bit is supported on Windows, 
except for TensorFlow, LightGBM, and ONNX-related functionality.

Prediction type & Example:
Classification/Categorization : Automatically divide customer feedback into positive and negative categories.
Regression/Predict continuous values : Predict the price of houses based on size and location.
Anomaly Detection : Detect fraudulent banking transactions.
Recommendations : Suggest products that online shoppers may want to buy, based on their previous purchases.
Time series/sequential data : Forecast the weather or product sales.
Image classification : Categorize pathologies in medical images.
Text classification : Categorize documents based on their content.
Sentence similarity :Measure how similar two sentences are.

Code workflow

The following diagram represents the application code structure, 
as well as the iterative process of model development:

    Collect and load training data into an IDataView object
    Specify a pipeline of operations to extract features and apply a machine learning algorithm
    Train a model by calling Fit() on the pipeline
    Evaluate the model and iterate to improve
    Save the model into binary format, for use in an application
    Load the model back into an ITransformer object
    Make predictions by calling CreatePredictionEngine.Predict()

MLContext : 
The MLContext class in ML.NET is the main entry point for interacting with all machine learning operations, 
including data loading, transformation, model training, evaluation, and deployment. 
It acts as a factory for creating various components that are essential for machine learning workflows in .NET applications. 
Each instance of MLContext can manage its own machine learning environment and resources.

Creating an MLContext Object:
An MLContext object is usually created at the start of a machine learning workflow. 
It holds configurations and instances for all the operations, and it manages memory and resources during model creation and training.

Key Properties and Methods of MLContext:
The MLContext object has several key properties and methods that provide access to machine learning operations. 
These are grouped into several areas:

a) Data Loading and Processing:
i. Data.LoadFromTextFile<T>(string path, ...)
    Loads data from a text file (e.g., CSV) into an IDataView, which is the primary data structure in ML.NET.    
    IDataView dataView = mlContext.Data.LoadFromTextFile<ModelInput>("data.csv", hasHeader: true, separatorChar: ',');
    
ii. Data.LoadFromEnumerable<T>(IEnumerable<T> data)
    Loads data from an in-memory collection like a list or array.
    List<ModelInput> dataList = GetData();
    IDataView dataView = mlContext.Data.LoadFromEnumerable(dataList);

iii. Data.Split(...)
    Splits the dataset into training and test datasets.
    var splitData = mlContext.Data.TrainTestSplit(dataView, testFraction: 0.2);

iv. Data.ShuffleRows(...)
    Randomly shuffles the rows of data, useful for cross-validation.
    IDataView shuffledData = mlContext.Data.ShuffleRows(dataView);

b) Data Transformation:
Transformations are used to modify, clean, or prepare data before feeding it to a machine learning algorithm.
i. Transforms
    The Transforms property provides various transformations, including normalization, text featurization, categorical encoding, and more. 
    Common transformations include:
    Text Featurization:
    var textPipeline = mlContext.Transforms.Text.FeaturizeText("Features", "TextColumn");
    One-Hot Encoding (for categorical data):
    var encodingPipeline = mlContext.Transforms.Categorical.OneHotEncoding("CategoryEncoded", "Category");
    Normalization (scaling numeric data):
    var normalizationPipeline = mlContext.Transforms.NormalizeMinMax("Features");
    Concatenation (combining multiple columns into a single feature vector):
    var concatPipeline = mlContext.Transforms.Concatenate("Features", new[] { "Column1", "Column2" });

c) Model Training and Algorithms
BinaryClassification, MulticlassClassification, Regression, Clustering, and Ranking
MLContext provides access to a variety of machine learning algorithms through different properties based on the type of task you’re solving.
    Binary Classification:
    var trainer = mlContext.BinaryClassification.Trainers.SdcaLogisticRegression();
    Multiclass Classification:
    var trainer = mlContext.MulticlassClassification.Trainers.SdcaMaximumEntropy();
    Regression:
    var trainer = mlContext.Regression.Trainers.FastTree();
    Clustering:
    var trainer = mlContext.Clustering.Trainers.KMeans();
    Ranking:
    var trainer = mlContext.Ranking.Trainers.FastTree();
These methods provide access to specific machine learning algorithms, and you can append them to data processing pipelines for training.

d) Model Evaluation
Once a model is trained, it's essential to evaluate its performance using evaluation metrics.
i. BinaryClassification.Evaluate(...)
    Evaluates a binary classification model using metrics like accuracy, precision, recall, F1 score, and AUC.
    var metrics = mlContext.BinaryClassification.Evaluate(predictions);
    Console.WriteLine($"Accuracy: {metrics.Accuracy}");
ii. MulticlassClassification.Evaluate(...)
    Evaluates a multiclass classification model with metrics like micro-accuracy, macro-accuracy, and log-loss.
    var metrics = mlContext.MulticlassClassification.Evaluate(predictions);
    Console.WriteLine($"Macro Accuracy: {metrics.MacroAccuracy}");
iii. Regression.Evaluate(...)
    Evaluates a regression model using metrics like R-squared, mean absolute error, and root mean square error.
    var metrics = mlContext.Regression.Evaluate(predictions);
    Console.WriteLine($"R-Squared: {metrics.RSquared}");
iv. Clustering.Evaluate(...)
    Evaluates a clustering model with metrics like normalized mutual information and average distance.
    var metrics = mlContext.Clustering.Evaluate(predictions);
    Console.WriteLine($"NMI: {metrics.NormalizedMutualInformation}");

e) Saving and Loading Models
i. Model.Save(...)
    Saves a trained model to disk so it can be reused later.
    mlContext.Model.Save(trainedModel, dataView.Schema, "model.zip");
ii. Model.Load(...)
    Loads a previously saved model from disk for making predictions.
    var loadedModel = mlContext.Model.Load("model.zip", out var schema);

f) AutoML
The Auto property gives access to ML.NET’s AutoML (automated machine learning) capabilities. 
This allows you to build models without manually selecting algorithms and parameters.
var experimentResult = mlContext.Auto().CreateRegressionExperiment(60).Execute(trainData, labelColumnName: "Label");

g) Time Series and Forecasting
ML.NET supports time series forecasting using Singular Spectrum Analysis (SSA). This is useful for tasks such as sales forecasting, inventory management, and more.
i. Forecasting.ForecastBySsa(...)
    A method for forecasting future values based on historical data.
    var forecastingPipeline = mlContext.Forecasting.ForecastBySsa(...);

h) Logging and Debugging
i. Log
The MLContext also has options for logging, which can help in debugging and monitoring the model training process.
MLContext mlContext = new MLContext();
mlContext.Log += (sender, e) => Console.WriteLine(e.Message);
i) Random Seed
i. MLContext(seed)
You can provide a seed value for random operations to ensure reproducibility of experiments. Setting a seed makes the training process deterministic.
MLContext mlContext = new MLContext(seed: 0);

Best Practices with MLContext
    Reuse MLContext: It is recommended to reuse a single instance of MLContext throughout your application.
    Creating multiple instances can lead to memory leaks or excessive resource usage.
    Thread Safety: The MLContext object is thread-safe, so you can share it across multiple threads in your application.


